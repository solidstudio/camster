{"version":3,"file":"static/js/649.9f9143b0.chunk.js","mappings":"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","sources":["camera/CameraUtils.ts","camera/AnimationManger.ts","camera/Camera.tsx"],"sourcesContent":["import React from \"react\";\nimport { isMobile } from 'react-device-detect';\nimport cv from \"@techstark/opencv-js\";\n\nexport const getVideoConstraints = () => {\n    let videoConstraints = {\n        facingMode: { exact: \"user\" },\n        width: { ideal: 1280 },\n        height: { ideal: 720 }\n    };\n    if(isMobile) {\n        videoConstraints = {\n          facingMode: { exact: \"environment\" },\n          width: { ideal: window.innerHeight },\n          height: { ideal: window.screen.width } \n        };\n      }\n    return videoConstraints;\n}\n\nexport const setupCanvasSize = (videoRef: any, canvasRef: any, config: any) => {\n    const video = videoRef?.current?.video;\n    const canvas = canvasRef.current;\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n}\n\nexport const renderVideoToCanvas = (videoRef: any, canvasRef: any, config: any, points: any) => {\n    const canv = videoRef?.current?.getCanvas();\n\n    if (canv) {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\", { willReadFrequently: true });\n        ctx.drawImage(videoRef.current.video, 0, 0, canv.width, canv.height);\n\n        const img = cv.imread(canvasRef.current);\n\n        const boxWidth = Math.round(canv.width * (config.documentWidth / 100));\n        const boxHeight = Math.round(canv.height * (config.documentHeight / 100));\n        let topLeftPoints = { x: canv.width / 2 - boxWidth / 4, y: canv.height / 2 - boxHeight / 2};\n        let bottomRightPoints = { x: canv.width / 2 + boxWidth / 4, y: canv.height / 2 + boxHeight / 2};\n        if(isMobile) {\n            topLeftPoints = { x: canv.width / 2 - boxWidth / 2, y: canv.height / 2 - boxHeight / 2};\n            bottomRightPoints = { x: canv.width / 2 + boxWidth / 2, y: canv.height / 2 + boxHeight / 2};\n        }\n\n\n        const white = [255, 255, 255, 255]; // white\n        cv.rectangle(img, topLeftPoints, bottomRightPoints, white, 2);\n\n        if (points && points.lastDetectedPoints && config.debug) {\n            const colorDebugRed = [255, 0, 0, 255]; // red\n            cv.rectangle(img, points.lastDetectedPoints[0], points.lastDetectedPoints[2], colorDebugRed, 2);\n        }\n\n        cv.imshow(canvasRef.current, img);\n        img.delete();\n    }\n\n};\n\nexport const detectDocument = (videoRef: any, canvasRef: any, config: any, updatePointDetected: any) => {\n    const video = videoRef?.current?.video;\n    // fixes bug https://github.com/opencv/opencv/issues/19922\n    video.height = video.videoHeight;\n    video.width = video.videoWidth;\n    const cap = new cv.VideoCapture(video);\n    const src = new cv.Mat(video.height, video.width, cv.CV_8UC4);\n    cap.read(src);\n\n\n    const gray = new cv.Mat();\n    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);\n    const blur = new cv.Mat();\n    cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);\n    cv.Canny(blur, blur, 50, 150);\n    const thresh = new cv.Mat();\n    cv.threshold(blur, thresh, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);\n    let contours = new cv.MatVector();\n    let hierarchy = new cv.Mat();\n\n    cv.findContours(\n      thresh,\n      contours,\n      hierarchy,\n      cv.RETR_CCOMP,\n      cv.CHAIN_APPROX_SIMPLE\n    );\n\n    let points: any = [];\n\n    if (contours.size()) {\n        let maxArea = 1000\n        let maxContourIndex = -1\n        for (let i = 0; i < contours.size(); ++i) {\n            let contourArea = cv.contourArea(contours.get(i));\n            if (contourArea > maxArea) {\n            maxContourIndex = i\n            }\n        }\n\n        if (maxContourIndex >= 0) {\n            const maxContour = contours.get(maxContourIndex);\n            const maxContourArea = cv.contourArea(maxContour);\n            if (maxContourArea > maxArea) {\n                points = getCornerPoints(maxContour);\n            }\n        }\n    }\n\n    src.delete();\n    gray.delete();\n    blur.delete();\n    thresh.delete();\n    contours.delete();\n    hierarchy.delete();\n\n    if (points[0] && points[2]) {\n        updatePointDetected(points);\n    }\n    points = [];\n\n};\n\nexport const getCornerPoints = (contour: any) => {\n    let points = [];\n    let rect = cv.minAreaRect(contour);\n    const center = rect.center\n\n    let topLeftPoint\n    let topLeftDistance = 0\n\n    let topRightPoint\n    let topRightDistance = 0\n\n    let bottomLeftPoint\n    let bottomLeftDistance = 0\n\n    let bottomRightPoint\n    let bottomRightDistance = 0\n\n    for (let i = 0; i < contour.data32S.length; i += 2) {\n        const point = { x: contour.data32S[i], y: contour.data32S[i + 1] };\n        const distance = Math.hypot(point.x - center.x, point.y - center.y);\n        if (point.x < center.x && point.y < center.y) {\n        if (distance > topLeftDistance) {\n            topLeftPoint = point\n            topLeftDistance = distance\n        }\n        } else if (point.x > center.x && point.y < center.y) {\n        if (distance > topRightDistance) {\n            topRightPoint = point\n            topRightDistance = distance\n        }\n        } else if (point.x < center.x && point.y > center.y) {\n        if (distance > bottomLeftDistance) {\n            bottomLeftPoint = point\n            bottomLeftDistance = distance\n        }\n        } else if (point.x > center.x && point.y > center.y) {\n        if (distance > bottomRightDistance) {\n            bottomRightPoint = point\n            bottomRightDistance = distance\n        }\n        }\n    }\n    points.push(topLeftPoint)\n    points.push(topRightPoint)\n    points.push(bottomRightPoint)\n    points.push(bottomLeftPoint)\n    return points\n};","class UniqueNameSet extends Set {\n    constructor(values: any) {\n        super(values);\n\n        const names: any = [];\n        for (let value of this) {\n            if (names.includes(value.name)) {\n                this.delete(value);\n            } else {\n                names.push(value.name);\n            }\n        }\n    }\n}\n\nclass AnimationManager {\n    private tasks: any = new UniqueNameSet([]);\n    private fps: number = 60; // Target FPS\n    private lastFrameTime: number = performance.now();\n    private animationId: number | null = null; // Store the animation frame ID\n  \n    private run = (currentTime: number) => {\n      const deltaTime = currentTime - this.lastFrameTime;\n  \n      // Ensure the tasks only run if enough time has passed to meet the target FPS\n      if (deltaTime > 1000 / this.fps) {\n        this.tasks.forEach((task: any) => {\n            const taskDeltaTime = currentTime - task.lastFrameTime;\n            if (taskDeltaTime > 1000 / task.fps) {\n                task.task(currentTime);\n                task.lastFrameTime = currentTime;\n            }\n        });\n        this.lastFrameTime = currentTime;\n      }\n  \n      this.animationId = requestAnimationFrame(this.run);\n    };\n  \n    public registerTask(task: FrameRequestCallback, fps: number) {\n      this.tasks.add({task, fps, name: task.toString(), lastFrameTime: 0});\n      if (this.tasks.size === 1) {\n        this.animationId = requestAnimationFrame(this.run); // Start the loop if this is the first task\n      }\n    }\n  \n    public unregisterTask(task: FrameRequestCallback) {\n      this.tasks.delete(task);\n      if (this.tasks.size === 0 && this.animationId !== null) {\n        cancelAnimationFrame(this.animationId); // Stop the loop if no tasks remain\n        this.animationId = null; // Reset the ID\n      }\n    }\n  }\n  \n  export const animationManager = new AnimationManager();","import React, {useRef} from \"react\";\nimport { useGlobalContext } from \"../GlobalContext\";\nimport { isMobile } from 'react-device-detect';\nimport Webcam from \"react-webcam\";\nimport DocPresets from \"./docPresets\"\nimport { getVideoConstraints, setupCanvasSize, renderVideoToCanvas, detectDocument } from \"./CameraUtils\";\nimport { animationManager } from \"./AnimationManger\";\n\nconst Camera = () => {\n\n  let [globalData, setGlobalData] = useGlobalContext();\n  if (!globalData) {\n    globalData = {\n      config: DocPresets.test\n    }\n  } else if (!globalData.config) {\n    globalData.config = DocPresets.test;\n  }\n  console.log('globalData', globalData);\n\n  console.log('isMobile', isMobile);\n\n  const videoWrapperRef = React.useRef<HTMLDivElement | null>(null);\n  const videoRef = React.useRef<Webcam>(null);\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n\n  const videoConstraints = getVideoConstraints();\n\n  const initialiseCanvas = () => {\n    setupCanvasSize(videoRef, canvasRef, globalData.config);\n  };\n\n  const renderVideo = () => {\n    renderVideoToCanvas(videoRef, canvasRef, globalData.config, globalData.autoCapture);\n  };\n\n  const runDetection = () => {\n    detectDocument(videoRef, canvasRef, globalData.config, updatePointDetected);\n  };\n\n  const updatePointDetected = (points: any) => {\n    const globalDataUpdate = globalData;\n    globalDataUpdate.autoCapture = {\n      lastDetectedPoints: points\n    };\n    setGlobalData(globalDataUpdate);\n  };\n\n  const videoStarted = () => {\n    // seems to have issues on ios without delay\n    setTimeout(() => {\n      initialiseCanvas();\n      animationManager.registerTask(renderVideo, 60);\n      animationManager.registerTask(runDetection, 10);\n    }, 2000);\n  }\n\n  return (\n    <div>\n      <div style={{position: 'relative'}}>\n        <div ref={videoWrapperRef}><Webcam videoConstraints={videoConstraints} ref={videoRef} onUserMedia={videoStarted} style={{position: 'absolute'}} /></div>\n        <div><canvas id=\"canvasOutput\" ref={canvasRef} style={{position: 'absolute'}}></canvas></div>\n      </div>\n      {/* <div style={{position: 'relative'}}><Link to=\"/\" reloadDocument>Back to settings</Link></div> */}\n      <div style={{position: 'relative'}}><a href=\"/camster\" >Back to settings</a></div>\n    </div>\n  );\n}\n\nexport default Camera;"],"names":["getCornerPoints","contour","points","center","cv","topLeftPoint","topRightPoint","bottomLeftPoint","bottomRightPoint","topLeftDistance","topRightDistance","bottomLeftDistance","bottomRightDistance","i","data32S","length","point","x","y","distance","Math","hypot","push","UniqueNameSet","Set","constructor","values","super","names","value","this","includes","name","delete","animationManager","tasks","fps","lastFrameTime","performance","now","animationId","run","currentTime","forEach","task","requestAnimationFrame","registerTask","add","toString","size","unregisterTask","cancelAnimationFrame","Camera","globalData","setGlobalData","useGlobalContext","config","DocPresets","test","console","log","isMobile","videoWrapperRef","React","videoRef","canvasRef","useRef","videoConstraints","getVideoConstraints","facingMode","exact","width","ideal","height","window","innerHeight","screen","renderVideo","renderVideoToCanvas","_videoRef$current2","canv","current","getCanvas","getContext","willReadFrequently","drawImage","video","img","boxWidth","round","documentWidth","boxHeight","documentHeight","topLeftPoints","bottomRightPoints","white","lastDetectedPoints","debug","colorDebugRed","autoCapture","runDetection","detectDocument","updatePointDetected","_videoRef$current3","videoHeight","videoWidth","cap","src","read","gray","blur","thresh","contours","hierarchy","maxArea","maxContourIndex","get","maxContour","globalDataUpdate","_jsxs","children","style","position","_jsx","ref","Webcam","onUserMedia","videoStarted","setTimeout","setupCanvasSize","_videoRef$current","canvas","id","href"],"sourceRoot":""}