{"version":3,"file":"static/js/649.26d2cf14.chunk.js","mappings":"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","sources":["camera/CameraUtils.ts","camera/AnimationManger.ts","camera/Camera.tsx"],"sourcesContent":["import React from \"react\";\nimport { isMobile } from 'react-device-detect';\nimport cv from \"@techstark/opencv-js\";\n\nexport const getVideoConstraints = () => {\n    let videoConstraints = {\n        facingMode: { exact: \"user\" },\n        width: { ideal: 1280 },\n        height: { ideal: 720 }\n    };\n    if(isMobile) {\n        videoConstraints = {\n          facingMode: { exact: \"environment\" },\n          width: { ideal: window.innerHeight },\n          height: { ideal: window.screen.width } \n        };\n      }\n    return videoConstraints;\n}\n\nexport const setupCanvasSize = (videoRef: any, canvasRef: any, config: any) => {\n    const video = videoRef?.current?.video;\n    const canvas = canvasRef.current;\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n}\n\nexport const renderVideoToCanvas = (videoRef: any, canvasRef: any, config: any, lastDetectedPoints: any) => {\n    const canv = videoRef?.current?.getCanvas();\n    if (canv) {\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\", { willReadFrequently: true });\n        ctx.drawImage(videoRef.current.video, 0, 0, canv.width, canv.height);\n\n        const img = cv.imread(canvasRef.current);\n\n        const boxWidth = Math.round(canv.width * (config.documentWidth / 100));\n        const boxHeight = Math.round(canv.height * (config.documentHeight / 100));\n        let topLeftPoints = { x: canv.width / 2 - boxWidth / 4, y: canv.height / 2 - boxHeight / 2};\n        let bottomRightPoints = { x: canv.width / 2 + boxWidth / 4, y: canv.height / 2 + boxHeight / 2};\n        if(isMobile) {\n            topLeftPoints = { x: canv.width / 2 - boxWidth / 2, y: canv.height / 2 - boxHeight / 2};\n            bottomRightPoints = { x: canv.width / 2 + boxWidth / 2, y: canv.height / 2 + boxHeight / 2};\n        }\n\n\n        const white = [255, 255, 255, 255]; // white\n        cv.rectangle(img, topLeftPoints, bottomRightPoints, white, 2);\n\n        if (lastDetectedPoints && config.debug) {\n            const colorDebugRed = [255, 0, 0, 255]; // red\n            cv.rectangle(img, lastDetectedPoints[0], lastDetectedPoints[2], colorDebugRed, 2);\n        }\n\n        cv.imshow(canvasRef.current, img);\n        img.delete();\n    }\n\n};\n\nexport const detectDocument = (videoRef: any, canvasRef: any, config: any, updatePointDetected: any) => {\n    const video = videoRef?.current?.video;\n    // fixes bug https://github.com/opencv/opencv/issues/19922\n    video.height = video.videoHeight;\n    video.width = video.videoWidth;\n    const cap = new cv.VideoCapture(video);\n    const src = new cv.Mat(video.height, video.width, cv.CV_8UC4);\n    cap.read(src);\n\n\n    const gray = new cv.Mat();\n    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);\n    const blur = new cv.Mat();\n    cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);\n    cv.Canny(blur, blur, 50, 150);\n    const thresh = new cv.Mat();\n    cv.threshold(blur, thresh, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);\n    let contours = new cv.MatVector();\n    let hierarchy = new cv.Mat();\n\n    cv.findContours(\n      thresh,\n      contours,\n      hierarchy,\n      cv.RETR_CCOMP,\n      cv.CHAIN_APPROX_SIMPLE\n    );\n\n    let points: any = [];\n\n    if (contours.size()) {\n        let maxArea = 1000\n        let maxContourIndex = -1\n        for (let i = 0; i < contours.size(); ++i) {\n            let contourArea = cv.contourArea(contours.get(i));\n            if (contourArea > maxArea) {\n            maxContourIndex = i\n            }\n        }\n\n        if (maxContourIndex >= 0) {\n            const maxContour = contours.get(maxContourIndex);\n            const maxContourArea = cv.contourArea(maxContour);\n            if (maxContourArea > maxArea) {\n                points = getCornerPoints(maxContour);\n            }\n        }\n    }\n\n    src.delete();\n    gray.delete();\n    blur.delete();\n    thresh.delete();\n    contours.delete();\n    hierarchy.delete();\n\n    if (points[0] && points[2]) {\n        updatePointDetected(points);\n    }\n    points = [];\n\n};\n\nexport const getCornerPoints = (contour: any) => {\n    let points = [];\n    let rect = cv.minAreaRect(contour);\n    const center = rect.center\n\n    let topLeftPoint\n    let topLeftDistance = 0\n\n    let topRightPoint\n    let topRightDistance = 0\n\n    let bottomLeftPoint\n    let bottomLeftDistance = 0\n\n    let bottomRightPoint\n    let bottomRightDistance = 0\n\n    for (let i = 0; i < contour.data32S.length; i += 2) {\n        const point = { x: contour.data32S[i], y: contour.data32S[i + 1] };\n        const distance = Math.hypot(point.x - center.x, point.y - center.y);\n        if (point.x < center.x && point.y < center.y) {\n        if (distance > topLeftDistance) {\n            topLeftPoint = point\n            topLeftDistance = distance\n        }\n        } else if (point.x > center.x && point.y < center.y) {\n        if (distance > topRightDistance) {\n            topRightPoint = point\n            topRightDistance = distance\n        }\n        } else if (point.x < center.x && point.y > center.y) {\n        if (distance > bottomLeftDistance) {\n            bottomLeftPoint = point\n            bottomLeftDistance = distance\n        }\n        } else if (point.x > center.x && point.y > center.y) {\n        if (distance > bottomRightDistance) {\n            bottomRightPoint = point\n            bottomRightDistance = distance\n        }\n        }\n    }\n    points.push(topLeftPoint)\n    points.push(topRightPoint)\n    points.push(bottomRightPoint)\n    points.push(bottomLeftPoint)\n    return points\n};","class UniqueNameSet extends Set {\n    constructor(values: any) {\n        super(values);\n\n        const names: any = [];\n        for (let value of this) {\n            if (names.includes(value.name)) {\n                this.delete(value);\n            } else {\n                names.push(value.name);\n            }\n        }\n    }\n}\n\nclass AnimationManager {\n    private tasks: any = new UniqueNameSet([]);\n    private fps: number = 60; // Target FPS\n    private lastFrameTime: number = performance.now();\n    private animationId: number | null = null; // Store the animation frame ID\n  \n    private run = (currentTime: number) => {\n      const deltaTime = currentTime - this.lastFrameTime;\n  \n      // Ensure the tasks only run if enough time has passed to meet the target FPS\n      if (deltaTime > 1000 / this.fps) {\n        this.tasks.forEach((task: any) => {\n            const taskDeltaTime = currentTime - task.lastFrameTime;\n            if (taskDeltaTime > 1000 / task.fps) {\n                task.task(currentTime);\n                task.lastFrameTime = currentTime;\n            }\n        });\n        this.lastFrameTime = currentTime;\n      }\n  \n      this.animationId = requestAnimationFrame(this.run);\n    };\n  \n    public registerTask(task: FrameRequestCallback, fps: number) {\n      this.tasks.add({task, fps, name: task.toString(), lastFrameTime: 0});\n      if (this.tasks.size === 1) {\n        this.animationId = requestAnimationFrame(this.run); // Start the loop if this is the first task\n      }\n    }\n  \n    public unregisterTask(task: FrameRequestCallback) {\n      this.tasks.delete(task);\n      if (this.tasks.size === 0 && this.animationId !== null) {\n        cancelAnimationFrame(this.animationId); // Stop the loop if no tasks remain\n        this.animationId = null; // Reset the ID\n      }\n    }\n  }\n  \n  export const animationManager = new AnimationManager();","import React, {useRef} from \"react\";\nimport { useGlobalContext } from \"../GlobalContext\";\nimport Webcam from \"react-webcam\";\nimport { getVideoConstraints, setupCanvasSize, renderVideoToCanvas, detectDocument } from \"./CameraUtils\";\nimport { animationManager } from \"./AnimationManger\";\n\nconst Camera = (config: any) => {\n\n  const [globalData, setGlobalData] = useGlobalContext();\n\n  const videoWrapperRef = React.useRef<HTMLDivElement | null>(null);\n  const videoRef = React.useRef<Webcam>(null);\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n\n  const videoConstraints = getVideoConstraints();\n\n  const initialiseCanvas = () => {\n    setupCanvasSize(videoRef, canvasRef, config);\n  };\n\n  const renderVideo = () => {\n    renderVideoToCanvas(videoRef, canvasRef, config, globalData.autoCapture.lastDetectedPoints);\n  };\n\n  const runDetection = () => {\n    detectDocument(videoRef, canvasRef, config, updatePointDetected);\n  };\n\n  const updatePointDetected = (points: any) => {\n    const globalDataUpdate = globalData;\n    globalDataUpdate.autoCapture.lastDetectedPoints = points;\n    setGlobalData(globalDataUpdate);\n  };\n\n  const videoStarted = () => {\n    // seems to have issues on ios without delay\n    setTimeout(() => {\n      initialiseCanvas();\n      animationManager.registerTask(renderVideo, 60);\n      animationManager.registerTask(runDetection, 10);\n    }, 2000);\n  }\n\n  return (\n    <div>\n      <div style={{position: 'relative'}}>\n        <div ref={videoWrapperRef}><Webcam videoConstraints={videoConstraints} ref={videoRef} onUserMedia={videoStarted} style={{position: 'absolute'}} /></div>\n        <div><canvas id=\"canvasOutput\" ref={canvasRef} style={{position: 'absolute'}}></canvas></div>\n      </div>\n      {/* <div style={{position: 'relative'}}><Link to=\"/\" reloadDocument>Back to settings</Link></div> */}\n      <div style={{position: 'relative'}}><a href=\"/camster\" >Back to settings</a></div>\n    </div>\n  );\n}\n\nexport default Camera;"],"names":["getCornerPoints","contour","points","center","cv","topLeftPoint","topRightPoint","bottomLeftPoint","bottomRightPoint","topLeftDistance","topRightDistance","bottomLeftDistance","bottomRightDistance","i","data32S","length","point","x","y","distance","Math","hypot","push","UniqueNameSet","Set","constructor","values","super","names","value","this","includes","name","delete","animationManager","tasks","fps","lastFrameTime","performance","now","animationId","run","currentTime","forEach","task","requestAnimationFrame","registerTask","add","toString","size","unregisterTask","cancelAnimationFrame","config","globalData","setGlobalData","useGlobalContext","videoWrapperRef","React","videoRef","canvasRef","useRef","videoConstraints","getVideoConstraints","facingMode","exact","width","ideal","height","isMobile","window","innerHeight","screen","renderVideo","renderVideoToCanvas","lastDetectedPoints","_videoRef$current2","canv","current","getCanvas","getContext","willReadFrequently","drawImage","video","img","boxWidth","round","documentWidth","boxHeight","documentHeight","topLeftPoints","bottomRightPoints","white","debug","colorDebugRed","autoCapture","runDetection","detectDocument","updatePointDetected","_videoRef$current3","videoHeight","videoWidth","cap","src","read","gray","blur","thresh","contours","hierarchy","maxArea","maxContourIndex","get","maxContour","globalDataUpdate","_jsxs","children","style","position","_jsx","ref","Webcam","onUserMedia","videoStarted","setTimeout","setupCanvasSize","_videoRef$current","canvas","id","href"],"sourceRoot":""}